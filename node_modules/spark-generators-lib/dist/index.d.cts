import { AstNode, Reference } from 'langium';
import { Generated } from 'langium/generate';

/******************************************************************************
 * This file was generated by langium-cli 3.0.3.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

type AbstractElement = EnumX | Module;
declare const AbstractElement = "AbstractElement";
type DATATYPE = 'boolean' | 'cnpj' | 'cpf' | 'currency' | 'date' | 'datetime' | 'decimal' | 'email' | 'file' | 'integer' | 'mobilePhoneNumber' | 'phoneNumber' | 'string' | 'uuid' | 'void' | 'zipcode';
type Entity = ImportedEntity | LocalEntity;
declare const Entity = "Entity";
type FEATURE_TYPE = 'authentication';
type LANGUAGETYPE = 'csharp-clean-architecture' | 'csharp-minimal-api' | 'java' | 'python';
type QualifiedName = string;
type Relation = ManyToMany | ManyToOne | OneToMany | OneToOne;
declare const Relation = "Relation";
type UseCaseElements = Actor | UseCase;
declare const UseCaseElements = "UseCaseElements";
interface Actor extends AstNode {
    readonly $container: UseCasesModel;
    readonly $type: 'Actor';
    comment?: string;
    fullName?: string;
    id: QualifiedName;
    superType?: Reference<Actor>;
}
declare const Actor = "Actor";
interface Attribute extends AstNode {
    readonly $container: LocalEntity;
    readonly $type: 'Attribute';
    blank: boolean;
    comment?: string;
    fullName?: string;
    max?: number;
    min?: number;
    name: string;
    type: DATATYPE;
    unique: boolean;
}
declare const Attribute = "Attribute";
interface AttributeEnum extends AstNode {
    readonly $container: EnumX;
    readonly $type: 'AttributeEnum';
    comment?: string;
    fullName?: string;
    name: string;
}
declare const AttributeEnum = "AttributeEnum";
interface Configuration extends AstNode {
    readonly $container: Model;
    readonly $type: 'Configuration';
    database_name?: string;
    description?: string;
    entity?: Reference<Entity>;
    feature?: FEATURE_TYPE;
    language?: LANGUAGETYPE;
    name?: string;
    package_path?: LANGUAGETYPE;
}
declare const Configuration = "Configuration";
interface Element extends AstNode {
    readonly $container: Parameter;
    readonly $type: 'Element';
    comment?: string;
    name: string;
    type: DATATYPE;
}
declare const Element = "Element";
interface EnumEntityAtribute extends AstNode {
    readonly $container: LocalEntity;
    readonly $type: 'EnumEntityAtribute';
    comment?: string;
    name: string;
    type: Reference<EnumX>;
}
declare const EnumEntityAtribute = "EnumEntityAtribute";
interface EnumX extends AstNode {
    readonly $container: Model | Module;
    readonly $type: 'EnumX';
    attributes: Array<AttributeEnum>;
    comment?: string;
    name: string;
}
declare const EnumX = "EnumX";
interface Event extends AstNode {
    readonly $container: UseCase;
    readonly $type: 'Event';
    action?: string;
    depends: Array<Reference<Event>>;
    description?: string;
    id: string;
    name_fragment?: string;
}
declare const Event = "Event";
interface FunctionEntity extends AstNode {
    readonly $container: LocalEntity;
    readonly $type: 'FunctionEntity';
    comment?: string;
    name: string;
    paramters: Array<Parameter>;
    response: DATATYPE;
}
declare const FunctionEntity = "FunctionEntity";
interface ImportedEntity extends AstNode {
    readonly $container: ModuleImport;
    readonly $type: 'ImportedEntity';
    name: string;
}
declare const ImportedEntity = "ImportedEntity";
interface LocalEntity extends AstNode {
    readonly $container: Module;
    readonly $type: 'LocalEntity';
    attributes: Array<Attribute>;
    comment?: string;
    enumentityatributes: Array<EnumEntityAtribute>;
    functions: Array<FunctionEntity>;
    is_abstract: boolean;
    name: string;
    relations: Array<Relation>;
    superType?: Reference<Entity>;
}
declare const LocalEntity = "LocalEntity";
interface ManyToMany extends AstNode {
    readonly $container: LocalEntity;
    readonly $type: 'ManyToMany';
    by?: Reference<LocalEntity>;
    comment?: string;
    fullName?: string;
    name: string;
    type: Reference<Entity>;
}
declare const ManyToMany = "ManyToMany";
interface ManyToOne extends AstNode {
    readonly $container: LocalEntity;
    readonly $type: 'ManyToOne';
    comment?: string;
    fullName?: string;
    name: string;
    type: Reference<Entity>;
}
declare const ManyToOne = "ManyToOne";
interface Model extends AstNode {
    readonly $type: 'Model';
    abstractElements: Array<AbstractElement | ModuleImport | UseCasesModel>;
    configuration?: Configuration;
}
declare const Model = "Model";
interface Module extends AstNode {
    readonly $container: Model | Module;
    readonly $type: 'Module';
    comment?: string;
    elements: Array<AbstractElement | LocalEntity>;
    name: QualifiedName;
}
declare const Module = "Module";
interface ModuleImport extends AstNode {
    readonly $container: Model;
    readonly $type: 'ModuleImport';
    entities: Array<ImportedEntity>;
    library: string;
    name: string;
    package_path: string;
}
declare const ModuleImport = "ModuleImport";
interface OneToMany extends AstNode {
    readonly $container: LocalEntity;
    readonly $type: 'OneToMany';
    comment?: string;
    fullName?: string;
    name: string;
    type: Reference<Entity>;
}
declare const OneToMany = "OneToMany";
interface OneToOne extends AstNode {
    readonly $container: LocalEntity;
    readonly $type: 'OneToOne';
    comment?: string;
    fullName?: string;
    name: string;
    type: Reference<Entity>;
}
declare const OneToOne = "OneToOne";
interface Parameter extends AstNode {
    readonly $container: FunctionEntity;
    readonly $type: 'Parameter';
    comment?: string;
    element: Array<Element> | Element;
}
declare const Parameter = "Parameter";
interface UseCase extends AstNode {
    readonly $container: UseCasesModel;
    readonly $type: 'UseCase';
    actors: Array<Reference<Actor>>;
    comment?: string;
    description?: string;
    events: Array<Event>;
    id: QualifiedName;
    name_fragment: string;
    superType?: Reference<UseCase>;
}
declare const UseCase = "UseCase";
interface UseCasesModel extends AstNode {
    readonly $container: Model;
    readonly $type: 'UseCasesModel';
    comment?: string;
    elements: Array<UseCaseElements>;
    id: QualifiedName;
}
declare const UseCasesModel = "UseCasesModel";

declare function generateConfigs$1(model: Model, target_folder: string): void;

declare function generateDebezium(model: Model, target_folder: string): void;

declare function generateEnum(enumx: EnumX, package_name: string): string;

declare function generate$2(model: Model, target_folder: string): void;

type RelationInfo = {
    tgt: LocalEntity;
    card: RelationType;
    owner: boolean;
};
type RelationType = 'OneToMany' | 'OneToOne' | 'ManyToOne' | 'ManyToMany';

declare function generateModel(cls: LocalEntity, is_supertype: boolean, relations: RelationInfo[], package_name: string, importedEntities: Map<ImportedEntity, ModuleImport | undefined>): Generated;

declare function generateModules$1(model: Model, target_folder: string): void;

declare function generateSchemaSQLHelper(model: Model, target_folder: string): void;

declare const index$2_generateDebezium: typeof generateDebezium;
declare const index$2_generateEnum: typeof generateEnum;
declare const index$2_generateModel: typeof generateModel;
declare const index$2_generateSchemaSQLHelper: typeof generateSchemaSQLHelper;
declare namespace index$2 {
  export { generate$2 as generate, generateConfigs$1 as generateConfigs, index$2_generateDebezium as generateDebezium, index$2_generateEnum as generateEnum, index$2_generateModel as generateModel, generateModules$1 as generateModules, index$2_generateSchemaSQLHelper as generateSchemaSQLHelper };
}

declare function generateConfigs(model: Model, target_folder: string): void;

declare function generate$1(model: Model, target_folder: string): void;

declare function generateGraphQL(application: Model, target_folder: string): void;

declare function generateModules(model: Model, target_folder: string): void;

declare const index$1_generateConfigs: typeof generateConfigs;
declare const index$1_generateGraphQL: typeof generateGraphQL;
declare const index$1_generateModules: typeof generateModules;
declare namespace index$1 {
  export { generate$1 as generate, index$1_generateConfigs as generateConfigs, index$1_generateGraphQL as generateGraphQL, index$1_generateModules as generateModules };
}

declare function generate(model: Model, target_folder: string): void;

declare const index_generate: typeof generate;
declare namespace index {
  export { index$2 as entity, index_generate as generate, index$1 as webservice };
}

export { index as java };
