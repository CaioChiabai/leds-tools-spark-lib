/******************************************************************************
 * This file was generated by langium-cli 3.0.3.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/
import type { AstNode, Reference, ReferenceInfo, TypeMetaData } from 'langium';
import { AbstractAstReflection } from 'langium';
export declare const SPARKTerminals: {
    WS: RegExp;
    ID: RegExp;
    INT: RegExp;
    STRING: RegExp;
    ML_COMMENT: RegExp;
    SL_COMMENT: RegExp;
};
export type AbstractElement = EnumX | Module;
export declare const AbstractElement = "AbstractElement";
export declare function isAbstractElement(item: unknown): item is AbstractElement;
export type DATATYPE = 'boolean' | 'cnpj' | 'cpf' | 'currency' | 'date' | 'datetime' | 'decimal' | 'email' | 'file' | 'integer' | 'mobilePhoneNumber' | 'phoneNumber' | 'string' | 'uuid' | 'void' | 'zipcode';
export declare function isDATATYPE(item: unknown): item is DATATYPE;
export type Entity = ImportedEntity | LocalEntity;
export declare const Entity = "Entity";
export declare function isEntity(item: unknown): item is Entity;
export type FEATURE_TYPE = 'authentication';
export declare function isFEATURE_TYPE(item: unknown): item is FEATURE_TYPE;
export type LANGUAGETYPE = 'csharp-clean-architecture' | 'csharp-minimal-api' | 'java' | 'python';
export declare function isLANGUAGETYPE(item: unknown): item is LANGUAGETYPE;
export type QualifiedName = string;
export declare function isQualifiedName(item: unknown): item is QualifiedName;
export type QualifiedNameWithWildcard = string;
export declare function isQualifiedNameWithWildcard(item: unknown): item is QualifiedNameWithWildcard;
export type Relation = ManyToMany | ManyToOne | OneToMany | OneToOne;
export declare const Relation = "Relation";
export declare function isRelation(item: unknown): item is Relation;
export type UseCaseElements = Actor | UseCase;
export declare const UseCaseElements = "UseCaseElements";
export declare function isUseCaseElements(item: unknown): item is UseCaseElements;
export interface Actor extends AstNode {
    readonly $container: UseCasesModel;
    readonly $type: 'Actor';
    comment?: string;
    fullName?: string;
    id: QualifiedName;
    superType?: Reference<Actor>;
}
export declare const Actor = "Actor";
export declare function isActor(item: unknown): item is Actor;
export interface Attribute extends AstNode {
    readonly $container: LocalEntity;
    readonly $type: 'Attribute';
    blank: boolean;
    comment?: string;
    fullName?: string;
    max?: number;
    min?: number;
    name: string;
    type: DATATYPE;
    unique: boolean;
}
export declare const Attribute = "Attribute";
export declare function isAttribute(item: unknown): item is Attribute;
export interface AttributeEnum extends AstNode {
    readonly $container: EnumX;
    readonly $type: 'AttributeEnum';
    comment?: string;
    fullName?: string;
    name: string;
}
export declare const AttributeEnum = "AttributeEnum";
export declare function isAttributeEnum(item: unknown): item is AttributeEnum;
export interface Configuration extends AstNode {
    readonly $container: Model;
    readonly $type: 'Configuration';
    database_name?: string;
    description?: string;
    entity?: Reference<Entity>;
    feature?: FEATURE_TYPE;
    language?: LANGUAGETYPE;
    name?: string;
    package_path?: LANGUAGETYPE;
}
export declare const Configuration = "Configuration";
export declare function isConfiguration(item: unknown): item is Configuration;
export interface Element extends AstNode {
    readonly $container: Parameter;
    readonly $type: 'Element';
    comment?: string;
    name: string;
    type: DATATYPE;
}
export declare const Element = "Element";
export declare function isElement(item: unknown): item is Element;
export interface EnumEntityAtribute extends AstNode {
    readonly $container: LocalEntity;
    readonly $type: 'EnumEntityAtribute';
    comment?: string;
    name: string;
    type: Reference<EnumX>;
}
export declare const EnumEntityAtribute = "EnumEntityAtribute";
export declare function isEnumEntityAtribute(item: unknown): item is EnumEntityAtribute;
export interface EnumX extends AstNode {
    readonly $container: Model | Module;
    readonly $type: 'EnumX';
    attributes: Array<AttributeEnum>;
    comment?: string;
    name: string;
}
export declare const EnumX = "EnumX";
export declare function isEnumX(item: unknown): item is EnumX;
export interface Event extends AstNode {
    readonly $container: UseCase;
    readonly $type: 'Event';
    action?: string;
    depends: Array<Reference<Event>>;
    description?: string;
    id: string;
    name_fragment?: string;
}
export declare const Event = "Event";
export declare function isEvent(item: unknown): item is Event;
export interface FunctionEntity extends AstNode {
    readonly $container: LocalEntity;
    readonly $type: 'FunctionEntity';
    comment?: string;
    name: string;
    paramters: Array<Parameter>;
    response: DATATYPE;
}
export declare const FunctionEntity = "FunctionEntity";
export declare function isFunctionEntity(item: unknown): item is FunctionEntity;
export interface ImportedEntity extends AstNode {
    readonly $container: ModuleImport;
    readonly $type: 'ImportedEntity';
    name: string;
}
export declare const ImportedEntity = "ImportedEntity";
export declare function isImportedEntity(item: unknown): item is ImportedEntity;
export interface LocalEntity extends AstNode {
    readonly $container: Module;
    readonly $type: 'LocalEntity';
    attributes: Array<Attribute>;
    comment?: string;
    enumentityatributes: Array<EnumEntityAtribute>;
    functions: Array<FunctionEntity>;
    is_abstract: boolean;
    name: string;
    relations: Array<Relation>;
    superType?: Reference<Entity>;
}
export declare const LocalEntity = "LocalEntity";
export declare function isLocalEntity(item: unknown): item is LocalEntity;
export interface ManyToMany extends AstNode {
    readonly $container: LocalEntity;
    readonly $type: 'ManyToMany';
    by?: Reference<LocalEntity>;
    comment?: string;
    fullName?: string;
    name: string;
    type: Reference<Entity>;
}
export declare const ManyToMany = "ManyToMany";
export declare function isManyToMany(item: unknown): item is ManyToMany;
export interface ManyToOne extends AstNode {
    readonly $container: LocalEntity;
    readonly $type: 'ManyToOne';
    comment?: string;
    fullName?: string;
    name: string;
    type: Reference<Entity>;
}
export declare const ManyToOne = "ManyToOne";
export declare function isManyToOne(item: unknown): item is ManyToOne;
export interface Model extends AstNode {
    readonly $type: 'Model';
    abstractElements: Array<AbstractElement | ModuleImport | UseCasesModel>;
    configuration?: Configuration;
}
export declare const Model = "Model";
export declare function isModel(item: unknown): item is Model;
export interface Module extends AstNode {
    readonly $container: Model | Module;
    readonly $type: 'Module';
    comment?: string;
    elements: Array<AbstractElement | LocalEntity>;
    name: QualifiedName;
}
export declare const Module = "Module";
export declare function isModule(item: unknown): item is Module;
export interface ModuleImport extends AstNode {
    readonly $container: Model;
    readonly $type: 'ModuleImport';
    entities: Array<ImportedEntity>;
    library: string;
    name: string;
    package_path: string;
}
export declare const ModuleImport = "ModuleImport";
export declare function isModuleImport(item: unknown): item is ModuleImport;
export interface OneToMany extends AstNode {
    readonly $container: LocalEntity;
    readonly $type: 'OneToMany';
    comment?: string;
    fullName?: string;
    name: string;
    type: Reference<Entity>;
}
export declare const OneToMany = "OneToMany";
export declare function isOneToMany(item: unknown): item is OneToMany;
export interface OneToOne extends AstNode {
    readonly $container: LocalEntity;
    readonly $type: 'OneToOne';
    comment?: string;
    fullName?: string;
    name: string;
    type: Reference<Entity>;
}
export declare const OneToOne = "OneToOne";
export declare function isOneToOne(item: unknown): item is OneToOne;
export interface Parameter extends AstNode {
    readonly $container: FunctionEntity;
    readonly $type: 'Parameter';
    comment?: string;
    element: Array<Element> | Element;
}
export declare const Parameter = "Parameter";
export declare function isParameter(item: unknown): item is Parameter;
export interface UseCase extends AstNode {
    readonly $container: UseCasesModel;
    readonly $type: 'UseCase';
    actors: Array<Reference<Actor>>;
    comment?: string;
    description?: string;
    events: Array<Event>;
    id: QualifiedName;
    name_fragment: string;
    superType?: Reference<UseCase>;
}
export declare const UseCase = "UseCase";
export declare function isUseCase(item: unknown): item is UseCase;
export interface UseCasesModel extends AstNode {
    readonly $container: Model;
    readonly $type: 'UseCasesModel';
    comment?: string;
    elements: Array<UseCaseElements>;
    id: QualifiedName;
}
export declare const UseCasesModel = "UseCasesModel";
export declare function isUseCasesModel(item: unknown): item is UseCasesModel;
export type SPARKAstType = {
    AbstractElement: AbstractElement;
    Actor: Actor;
    Attribute: Attribute;
    AttributeEnum: AttributeEnum;
    Configuration: Configuration;
    Element: Element;
    Entity: Entity;
    EnumEntityAtribute: EnumEntityAtribute;
    EnumX: EnumX;
    Event: Event;
    FunctionEntity: FunctionEntity;
    ImportedEntity: ImportedEntity;
    LocalEntity: LocalEntity;
    ManyToMany: ManyToMany;
    ManyToOne: ManyToOne;
    Model: Model;
    Module: Module;
    ModuleImport: ModuleImport;
    OneToMany: OneToMany;
    OneToOne: OneToOne;
    Parameter: Parameter;
    Relation: Relation;
    UseCase: UseCase;
    UseCaseElements: UseCaseElements;
    UseCasesModel: UseCasesModel;
};
export declare class SPARKAstReflection extends AbstractAstReflection {
    getAllTypes(): string[];
    protected computeIsSubtype(subtype: string, supertype: string): boolean;
    getReferenceType(refInfo: ReferenceInfo): string;
    getTypeMetaData(type: string): TypeMetaData;
}
export declare const reflection: SPARKAstReflection;
